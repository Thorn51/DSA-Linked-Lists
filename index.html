<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="styles.css" />
    <title>DSA - Linked Lists</title>
  </head>
  <body>
    <h1>Linked Lists</h1>
    <p></p>
    <section class="examples">
      <h2>Node</h2>
      <p>
        The unit of memory holding a single item in a linked list is a node in
        the list. A node can be allocated from anywhere in the memory, it does
        not have to be next to the previously allocated node.
      </p>
      <p>
        Each node consists of a value and a pointer to the next node in the
        sequence. This type of linked list is called a singly linked list. There
        is also a type of linked list called a doubly linked list where nodes
        contain a pointer to the previous node in addition to the next.
      </p>
      <pre>
        <code>
            class _Node {
                constructor(value, next) {
                    this.value = value;
                    this.next = next;
                }
            }
        </code>
      </pre>
      <p class="note">
        <span class="bold">NOTE:</span> The node class is prefixed wiht an
        underscore. This indicates that the node class is a private class that
        should not be accessible by anything other than the linked list class.
      </p>
      <h2>Linked List Class</h2>
      <p>
        The linked list has a head to indicate the beginning of the list. The
        head always contains the 1st node. In this case, we start with an empty
        list, represented by null.
      </p>
      <pre>
        <code>
            class LinkedList {
                constructor() {
                  this.head = null;
                }
            }
        </code>
      </pre>
      <h2>Linked List Methods</h2>
      <p>
        The primary operations in a linked list are insert, remove, and get
        (find).
      </p>
      <h2>Insertion</h2>
      <p>
        There can be 3 different implementations of the insert operation in a
        list. An item can be inserted:
      </p>
      <ul>
        <li>Insert at beginning of list - insertFirst(item)</li>
        <li>Insert at the end of the list - insertLast(item)</li>
        <li>Insert between existing nodes - insertAt(item)</li>
      </ul>
      <h3>Insert First</h3>
      <p>To insert a value at the beginning of the list:</p>
      <ul>
        <li>Create a new node item</li>
        <li>Point head to that new node</li>
      </ul>
      <pre>
        <code>
            ...

            insertFirst(item) {
                this.head = new _Node(item, this.head);
            }
            ...
        </code>
      </pre>
      <h3>Insert Last</h3>
      <p>To insert a value at the end of the list</p>
      <ul>
        <li>Create a new node</li>
        <li>
          If list is empty then insert the new item using insertFirst() method
        </li>
        <li>
          Start at the beginning of the list and move through the list until you
          reach the end of the list
        </li>
        <li>Set the end node's next point to the new node</li>
        <li>
          The new node's next pointer is null, null indicates the end of the
          list
        </li>
      </ul>
      <pre>
        <code>
            insertLast(item) {
                if(this.head === null) {
                  this.insertFirst(item);
                } else {
                  let tempNode = this.head;
                  while (tempNode.next !== null) {
                    tempNode = tempNode.next;
                  }
                  tempNode.next = new _Node(item, null)
                }
            
            }
        </code>
      </pre>
      <h2>Retrieval</h2>
      <p>To retrieve a value in a linked list:</p>
      <ul>
        <li>Check if list is empty</li>
        <li>Traverse list</li>
        <li>Compare the value in each node</li>
        <li>When value found, return value</li>
      </ul>
      <pre>
        <code>
            ...

            find(item) {

                // Start at the head
                let currNode = this.head;
                
                // Check if list is empty
                if (!this.head) {
                  return null;
                }
                
                // Check for the item
                while (currNode.value !== item) {
                  
                  // Return null if the end of the list is reached without finding item
                  
                  if (currNode.next === null) {
                    return null;
                  } else {
                    currNode = currNode.next;
                  }
                }
                
                // Return the node when it is found
                return currNode;
            }

            ...
        </code>
      </pre>
      <h2>Removal</h2>
      <p>
        Removing a node from the linked list requires managing either the head
        or the pointers in the linked list. If removing the first item we need
        to update the next node to be the head. Removing other nodes requires
        pointer reassignment. There are three cases that must be managed to
        properly update the nodes impacted by the removal of a node:
      </p>
      <ul>
        <li>Update Head - delete the first node of the list</li>
        <li>
          Update Previous Pointer to Null - delete the last node of the list
          (change one pointer)
        </li>
        <li>
          Update Adjacent Pointers - delete a node between other nodes (change
          two pointers)
        </li>
      </ul>
      <pre>
        <code>
            ...

            remove(item) {

                // if the list is empty 
                if(!this.head) {
                  return null;
                }
            
                // If the node to be removed is the head, make next node the head
                if(this.head.value === item) {
                  this.head = this.head.next;
                  return
                }
            
                // Start at the head
                let currNode = this.head
            
                // Keep track of previous head
                let previousNode = this.head
            
                while((currNode !== null) && (currNode.value !== item)) {
                  // save the previous node
                  previousNode = currNode;
                  currNode = currNode.next
                }
                if(currNode === null) {
                  console.log('Item not found')
                  return
                }
                previousNode.next = currNode.next
            }

            ...
        </code>
      </pre>
    </section>
    <section class="drills">
      <h2>Drills</h2>
      <h3>1. Create a linked list class</h3>
      <p class="question">
        Walk through the linked list code in the curriculum and understand it
        well. Then write a linked list class and its core functions
        (insertFirst, insertLast, remove, find) from scratch.
      </p>
      <pre>
        <code>
        </code>
      </pre>
      <p class="answer"><span class="bold">Answer:</span></p>
      <p class="note"><span class="bold">NOTE:</span></p>
      <h3>2. Creating a singly linked list</h3>
      <p class="question">
        Write a function main. Within the function, using the linked list class
        above, create a linked list with the name SLL and add the following
        items to your linked list: `Apollo, Boomer, Helo, Husker, Starbuck`.
      </p>
      <ul>
        <li>Add `Tauhida` to the list.</li>
        <li>Remove `Husker` from the list.</li>
        <li>
          Implement a function called `insertBefore()` in the class that inserts
          a new node before a given node containing a key.
        </li>
        <li>
          Implement a function called `insertAfter()` in the class that inserts
          a new node after a node containing the key.
        </li>
        <li>
          Implement a function called `insertAt()` that inserts an item at a
          specific position in the linked list.
        </li>
        <li>
          Add `Athena` before Boomer using your `insertBefore()` function.
        </li>
        <li>Add `Hotdog` after `Hello` using the `insertAfter()` method.</li>
        <li>
          Using the `insertAt()` method insert `Kat` in the `3rd` position of
          the list.
        </li>
        <li>Remove `Tauhida` from the list.</li>
      </ul>
      <pre>
        <code>
        </code>
      </pre>
      <p class="answer"><span class="bold">Answer:</span></p>
      <p class="note"><span class="bold">NOTE:</span></p>
      <h3>3. Supplemental functions for a linked list</h3>
      <p class="question">
        Implement the following functions that operate on your linked list
        class. Note that these should be free functions instead of methods of
        the linked list class, so implement them outside the linked list class.
        Test each function using the list created in exercise 1.
      </p>
      <ul>
        <li>`display`: displays the linked list</li>
        <li>`size`: returns the size of the linked list</li>
        <li>
          `isEmpty`: finds if the list is empty or not (without using the size()
          function)
        </li>
        <li>
          `findPrevious`: finds the node before the item you are looking for
        </li>
        <li>`findLast`: returns the last node in the linked list</li>
      </ul>
      <pre>
        <code>
        </code>
      </pre>
      <p class="answer"><span class="bold">Answer:</span></p>
      <p class="note"><span class="bold">NOTE:</span></p>
      <h3>4. Mystery program</h3>
      <p class="question">
        Analyze the following function (without running it in an IDE) to
        determine what problem it is trying to solve. What is the time
        complexity of this algorithm?
      </p>
      <pre>
        <code>
            function WhatDoesThisProgramDo(lst) {
                let current = lst.head;
                while (current !== null) {
                    let newNode = current;
                    while (newNode.next !== null) {
                        if (newNode.next.value === current.value) {
                            newNode.next = newNode.next.next;
                        }
                        else {
                            newNode = newNode.next;
                        }
                    }
                    current = current.next;
                }
            }
        </code>
      </pre>
      <p class="answer"><span class="bold">Answer:</span></p>
      <p class="note"><span class="bold">NOTE:</span></p>
      <h3>5. Reverse a list</h3>
      <p class="question">
        Write an algorithm to reverse a linked list. The time complexity of your
        algorithm should be linear (O(n)). For this exercise, notice we are not
        asking you just to print the linked list in reverse or use another
        linked list to store the value in reverse order. Your program should
        reverse the direction of a given singly linked list. In other words, all
        pointers should point backward. BONUS: Solve this problem using both
        recursive and iterative algorithms.
      </p>
      <pre>
        <code>
        </code>
      </pre>
      <p class="answer"><span class="bold">Answer:</span></p>
      <p class="note"><span class="bold">NOTE:</span></p>
      <h3>6. 3ed from the end</h3>
      <p class="question">
        Write an algorithm to find the 3rd element from the end of a linked
        list. Note You may be tempted to add a length property to your linked
        list class. The length property is not a typical property of linked
        list, therefore don't make any modification to the linked list class
        that is provided to you.
      </p>
      <pre>
        <code>
        </code>
      </pre>
      <p class="answer"><span class="bold">Answer:</span></p>
      <p class="note"><span class="bold">NOTE:</span></p>
      <h3>7. Middle of a list</h3>
      <p class="question">
        Write an algorithm to find the middle element of a linked list. Note You
        may be tempted to add a length property to your linked list class. The
        length property is not a typical property of linked list, therefore
        don't make any modification to the linked list class that is provided to
        you. Also, finding the size of the linked list using the size() function
        and dividing it by half will not find the correct middle of the linked
        list. So, don't use either of these approaches.
      </p>
      <pre>
        <code>
        </code>
      </pre>
      <p class="answer"><span class="bold">Answer:</span></p>
      <p class="note"><span class="bold">NOTE:</span></p>
      <h3>8. Cycle in a list</h3>
      <p class="question">
        Write an algorithm to find whether a linked list has a cycle (i.e.,
        whether a node in the list has its next value pointing to an earlier
        node in the list). For this exercise, create a linked list with the name
        CycleList. Be sure to insert nodes in the list so that it has a cycle.
        Then test your program with a cycleList function.
      </p>
      <pre>
        <code>
        </code>
      </pre>
      <p class="answer"><span class="bold">Answer:</span></p>
      <p class="note"><span class="bold">NOTE:</span></p>
      <h3>9. Sorting a list</h3>
      <p class="question">
        Write an algorithm that will sort a given linked list. For example given
        a list such as `3->2->5->7->1`, your program will output the sorted
        version of this list which will be `1->2->3->5->7`. You may not use
        another list or any other data structure such as an array to store the
        data. Also, you can only go through the list once, O(n) runtime.
      </p>
      <pre>
        <code>
        </code>
      </pre>
      <p class="answer"><span class="bold">Answer:</span></p>
      <p class="note"><span class="bold">NOTE:</span></p>
    </section>
    <script type="module" src="linked-list.js"></script>
    <script type="module" src="main.js"></script>
  </body>
</html>
